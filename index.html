<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" media="screen" href="demo.css" type="text/css" />
    <title>Image formats comparison</title>
    <script async src="js/pica.min.js"></script>
</head>

<body style="max-width: 100%;">

    <div class="demo" style="margin-left: auto; margin-right: auto; overflow:hidden;">
        <table>
            <tr>
                <td class="title" colspan=3>
                    <select id="subsetSel" style="font-size: 1.1em; margin-bottom: 1em;">
                    </select>
                </td>
            </tr>
            <tr>
                <td class="title" colspan=3>
                    <select id="fileSel" style="font-size: 1.1em; margin-bottom: 1em;">
                    </select>
                </td>
            </tr>
            <tr>
                <td class="title" style="width:16em;padding-left:4em;text-align:right;">
                    <select id="leftSel" style="font-size: 1.1em;">
                    </select>
                    <select id="leftQual" style="font-size: 1.1em;">
                        <option value="l">Large</option>
                        <option value="m">Medium</option>
                        <option value="s" selected>Small</option>
                        <option value="t">Tiny</option>
                    </select>
                </td>
                <td class="center-head" id="center-head">
                    --- vs ---
                </td>
                <td class="title" style="width:16em;padding-right:4em;text-align:left;">
                    <select id="rightSel" style="font-size: 1.1em;">
                    </select>
                    <select id="rightQual" style="font-size: 1.1em;">
                        <option value="l">Large</option>
                        <option value="m">Medium</option>
                        <option value="s" selected>Small</option>
                        <option value="t">Tiny</option>
                    </select>
                </td>
            </tr>
            <tr>
                <td colspan=3 style="padding-top: 1em; padding-bottom: 1em;">
                    <div id="rightContainer" style="margin-left: auto; margin-right: auto; position: relative; width:800px; height:800px;">
                        <div id="leftContainer" style="border-right: 1px dotted white; width:800px; height:800px;"></div>
                        <div id="leftText" style="position: absolute; color: white; padding:.2em .5em .2em .5em;"></div>
                        <div id="rightText" style="position: absolute; color: white; padding:.2em .5em .2em .5em;"></div>
                    </div>
                </td>
            </tr>
            <tr>
                <td class="title" colspan="3" style="width: 20%; text-align: center; padding-bottom: 1.25em;">
                    <select id="scaleSel" style="width:5em ;font-size: 1em;text-align:center;">
                        <option ratio="1:3" value="0.5773502692">1/3</option>
                        <option ratio="1:2" value="0.7071067812">1/2</option>
                        <option ratio="1:1" value="1" selected>---</option>
                        <option ratio="2:1" value="1.414213562">2x</option>
                        <option ratio="3:1" value="1.732050808">3x</option>
                    </select>
                </td>
            </tr>
        </table>
    </div>
    <div class="caption">
        <h1>image-formats-comparision</h1>
        <h2>Notes</h2>
        <p>Each image size is targeting a constant bits per pixel data density in order to get a range of quality levels from different images at each size. Each size is a particular fraction of a uncompressed (24 BPP) image. The "Large" size targets 5% of the uncompressed size (24/20 = 1.2 BPP). Medium targets half the size of Large, Small half the size of Medium, and Tiny half the size of Small.</p>
        <p>Rescaling in the web page (when needed) is through Lanczos2.</p>
        <p>This page is based on <a href="http://people.xiph.org/~xiphmont/demo/daala/update1-tool2b.shtml" target="_blank">Xiph.org's</a>Daala comparison page. <a href="https://github.com/xooyoozoo/yolo-octo-bugfixes" target="_blank">Originally developed by xooyoozoo</a>. This version is a clean fork of <a href="https://wyohknott.github.io/image-formats-comparison/" target="_blank">Wyohknott's improved version</a> with additional updates and modifications.
        <p>A list of sources for the images can be found in <a href="https://afontenot.github.io/image-formats-comparison/cite_images.txt" target="_blank">this text file</a>.</p>
        <p>Last updated: April 2020.</p>
        <h2>Changes</h2>
        <ul>
            <li>Instead of using the original Daala test images, which are 4:2:0 subsampled, I recreated the image set from the original high-res sources, downscaling to the same sized source images as the Daala set, but not subsampled (4:4:4). This fixes <a href="https://github.com/WyohKnott/image-formats-comparison/issues/4" target="_blank">this bug</a>.</li>
            <li>I wrote my own script for generating the comparison images, which uses a binary search to quickly find the quality level that generates the image with the closest file size to the target. It will be added to the repository when I have time to clean it up.</li>
            <li><b>All</b> images that can't be rendered by the browser are now served as PNGs, instead of trying (in some cases) to decode with Javascript. The images were heavily compressed (losslessly) to take up less space, and this requires less decoding power on the viewer end. This change also fixes <a href="https://github.com/WyohKnott/image-formats-comparison/issues/10" target="_blank">this bug</a> and also <a href="https://github.com/WyohKnott/image-formats-comparison/issues/11" target="_blank">this one</a>.</li>
            <li>A number of codecs from the previous version were dropped. These are Daala, KDU (JPEG2000), OpenJpeg (JPEG2000), PIK, VP9, and WebP. WebP was dropped because it doesn't support unsubsampled images, making it a bad candidate for a high quality photography codec. PIK was dropped because I couldn't get it running on my computer; I think it might require newer CPU features. I'd like to add it back in the future if possible. OpenJpeg was removed because the results seemed to be fairly low quality. KDU was removed because it crashed on input images with certain characters in the filename. I might work on adding it back later. As for Daala and VP9, I think their features have been mostly subsumed into newer codecs that current development effort is focused on.</li>
            <li><b>JPEGXL</b> was added to the comparison.</li>
            <li>All codecs were updated to their latest available releases, see below. This fixes <a href="https://github.com/WyohKnott/image-formats-comparison/issues/8" target="_blank">this issue</a>.</li>
        </ul>
        <h2>Versions and Commands</h2>
        <p><b>AV1 (aom reference encoder 1.0.0.errata1):</b></p>
        <p><pre>aomenc --i444 --passes=2 --end-usage=q --cq-level={quality} -o {output.webm} {input.y4m}</pre></p>
        <p><b>BPG (libbpg 0.9.8-1):</b></p>
        <p><pre>bpgenc -m 9 -f 444 -q {quality} -o {output.bpg} {input.png}</pre></p>
        <p><b>FLIF (FLIF 0.3-6):</b></p>
        <p><pre>flif -E 95 -Q {quality} {input.png} {output.flif}</pre></p>
        <p><b>JPEGXL (libjpeg-xl git:0709f3a4 2020-02-19):</b></p>
        <p><pre>cjpegxl -s 9 -q {quality} {input.png} {output.jxl}</pre></p>
        <p><b>JPEGXR (jxrlib 0.2.1):</b></p>
        <p><pre>JxrEncApp -d 3 -q {quality} -o {output.jxr} -i {input.ppm}</pre></p>
        <p><b>MozJPEG (mozjpeg 3.3.1):</b></p>
        <p><pre>cjpeg -quality {quality} -outfile {output.jpg} {input.png}</pre></p>
    </div>

    <script>
        var select = {
            file: getElId('fileSel'), scale: getElId('scaleSel'),
            left: getElId('leftSel'), right: getElId('rightSel'),
            subset: getElId('subsetSel')
        };

        var view = {
            left: getElId('leftContainer'),
            right: getElId('rightContainer')
        };

        var viewOptions = {
            file: '', scale: '',
            left: '', leftQ: '',
            right: '', rightQ: ''
        };

        var offset = {
            width: (view.right).getBoundingClientRect().width,
            height: (view.right).getBoundingClientRect().height
        };
        var split = {
            x: 0.5 * offset.width,
            y: 0.5 * offset.height
        };
        var splitTarget = {
            x: split.x,
            y: split.y
        };
        var splitStep = {
            x: 0,
            y: 0
        };

        var infoText = {
            left: getElId('leftText'),
            right: getElId('rightText'),
            center: getElId('center-head')
        };

        var urlFolder, urlFile;
        var timer;
        var textHeight = infoText.left.offsetHeight;
        var first = 1;
        var splitMode = 1;

        var canvases = {
            left: prepCanvas(800, 800),
            right: prepCanvas(800, 800),
            leftScaled: prepCanvas(100, 100),
            rightScaled: prepCanvas(100, 100)
        }
        function prepCanvas(width, height, which) {
            var c;

            if (which !== undefined) {
                c = which;
                c.getContext("2d").clearRect(0, 0, c.width, c.height);
            }
            else { c = document.createElement("canvas"); }

            c.width = width;
            c.height = height;
            return c;
        }

        /* file|scale|codec|qual > setSide > setImage > processCanvasScale > setSize > setSplit */
        select.file.onchange = function () {
            //select.scale.options[2].selected = true;
            setFile();
        };

        select.scale.onchange = processCanvasScale;

        select.left.onchange = function () {
            setSide('left');
        };
        select.right.onchange = function () {
            setSide('right');
        };

        leftQual.onchange = function () {
            setSide('left');
        };
        rightQual.onchange = function () {
            setSide('right');
        };

        function getElId(id) {
            return document.getElementById(id);
        }

        function getSelValue(el, attr) {
            return el.options[el.selectedIndex].getAttribute(attr);
        }

        /* Get web-friendly string */
        function getSlugName(str) {
            str = str.replace(/^\s+|\s+$/g, ''); // trim
            str = str.toLowerCase();

            // remove accents, swap ñ for n, etc
            var from = "ãàáäâẽèéëêìíïîõòóöôùúüûñç·/_,:;";
            var to = "aaaaaeeeeeiiiiooooouuuunc------";
            for (var i = 0, l = from.length; i < l; i++) {
                str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i));
            }

            str = str.replace(/[^a-z0-9 -]/g, '') // remove invalid chars
                .replace(/\s+/g, '-') // collapse whitespace and replace by -
                .replace(/-+/g, '-'); // collapse dashes

            return str;
        }

        /* Uses Lanczos2 for rescaling. In-browser too blurry. Lanczos3 too slow. */
        function processCanvasScale(canvas, choseSide) {
            if (choseSide) {
                // Process only one side
                scaleCanvas(canvas, choseSide);
            } else {
                // Process both sides at once
                scaleCanvas(canvases.right, 'right');
                scaleCanvas(canvases.left, 'left');
            }

            function scaleCanvas(inCanvas, side) {
                var scale = getSelValue(scaleSel, 'value');
                var outCnvs = canvases[side + 'Scaled'];

                if (scale == 1) {
                    viewOptions.scale = '';
                    prepCanvas(100, 100, outCnvs);
                    return setSize(inCanvas, side);
                }

                var width = Math.round(inCanvas.width * scale);
                var height = Math.round(inCanvas.height * scale);

                viewOptions.scale = '*' + getSelValue(scaleSel, 'ratio');
                prepCanvas(width, height, outCnvs);

                window.pica.WW = true;
                window.pica.resizeCanvas(inCanvas, outCnvs,
                    {
                        quality: 2, alpha: false, unsharpAmount: 0,
                        unsharpThreshold: 0, transferable: true
                    },
                    function () { setSize(outCnvs, side); }
                )
            }
        }

        function setSize(inCanvas, side) {
            var src, width, height, el;
            src = inCanvas.toDataURL();
            width = inCanvas.width;
            height = inCanvas.height;
            el = view[side];
            if (first) {
                view.left.style.height = height + "px";
                view.right.style.height = height + "px";
            } else el.style.height = height + "px";

            el.style.width = width + "px";
            var styleEl = getElId(side + "SideStyle");
            if (styleEl == null) {
                styleEl = document.createElement("style");
                styleEl.id = side + "SideStyle";
                styleEl.textContent = "#" + el.id + "{}";
                document.head.appendChild(styleEl);
            }
            styleEl.sheet.cssRules[0].style.backgroundImage = 'url(\"' + src + '\")';
            el.style.backgroundColor = "";
            el.style.opacity = 1;
            if (el == view.right) {
                offset = {
                    width: width,
                    height: height
                };
                if (first) {
                    split.x = splitTarget.x = width * .5;
                    split.y = splitTarget.y = height * .5;
                    first = 0;
                }
            }
            switchMode();
            setSplit();
            window.location.hash = (viewOptions.file).concat(viewOptions.scale,
                '&', viewOptions.left, '=', viewOptions.leftQ,
                '&', viewOptions.right, '=', viewOptions.rightQ);
        }

        function setSplit() {
            if (!timer) {
                timer = setInterval(function () {
                    splitStep.x *= .5;
                    splitStep.y *= .5;
                    splitStep.x += (splitTarget.x - split.x) * .1;
                    splitStep.y += (splitTarget.y - split.y) * .1;

                    split.x += splitStep.x;
                    split.y += splitStep.y;

                    if (Math.abs(split.x - splitTarget.x) < .5)
                        split.x = splitTarget.x;
                    if (Math.abs(split.y - splitTarget.y) < .5)
                        split.y = splitTarget.y;

                    view.left.style.width = split.x + "px";
                    infoText.left.style.right = (offset.width - split.x) + "px";
                    infoText.left.style.bottom = (offset.height - split.y) + "px";
                    infoText.right.style.left = (split.x + 1) + "px";
                    infoText.right.style.bottom = (offset.height - split.y) + "px";

                    if (split.x == splitTarget.x && split.y == splitTarget.y) {
                        clearInterval(timer);
                        timer = null;
                    }
                }, 20);
            }
        }

        function setImage(side, pathBase, codec, setText) {
            var canvas = canvases[side];

            if (side == 'left' || first) {
                view[side].style.backgroundColor = "#c6c6c6";
                view[side].style.backgroundImage = "";
            };
            view[side].style.opacity = 0.5;

            var path = urlFolder.concat(pathBase, '/', urlFile, '.', codec);
            var xhr = new XMLHttpRequest();

            xhr.open("GET", path, true);
            xhr.responseType = "arraybuffer";

            xhr.onload = function () {

                var mimeCodec = (codec == 'jxr') ? 'vnd.ms-photo' : codec;
                var blob = new Blob([xhr.response], {
                    type: "image/" + mimeCodec
                });
                var blobPath = window.URL.createObjectURL(blob);

                var canvas = canvases[side];
                canvas.getContext("2d").clearRect(0, 0, canvas.width, canvas.height);
                var area = canvas.width * canvas.height;
                setText((xhr.response.byteLength / 1024).toFixed(1) + " KiB", (xhr.response.byteLength * 8 / area).toFixed(2) + " bpp");

                var image = new Image();
                image.onload = function () {
                    canvas.width = image.width;
                    canvas.height = image.height;
                    canvas.getContext("2d").drawImage(image, 0, 0);
                    processCanvasScale(canvas, side);
                    window.URL.revokeObjectURL(blobPath);
                };
                image.onerror = function () {
                    this.onerror=null;
                    image.src = urlFolder.concat(pathBase, '/', urlFile, '.', 'png');
                };
                image.src = blobPath;
            };
            xhr.send();
        }

        function setSide(side) {
            var isRight = (side == 'right') ? 1 : 0;
            var whichQual = (isRight) ? rightQual : leftQual;
            var image = getSelValue(select[side], 'value');
            var pathBase = getSelValue(select[side], 'folder');

            if (pathBase != 'original') {
                whichQual.disabled = false;
                var quality = whichQual.options[whichQual.selectedIndex].innerHTML.toLowerCase() + '/';
            } else {
                whichQual.disabled = true;
                var quality = '';
            }

            pathBase = quality + pathBase;
            viewOptions[side] = image;
            viewOptions[side + 'Q'] = getSelValue(whichQual, 'value');

            setImage(side.toLowerCase(), pathBase, image,
                function (kbytes, bpp) {
                    infoText[side].innerHTML = (isRight) ? "&rarr;&nbsp;" + kbytes + "<br>&emsp;&nbsp;" + bpp : kbytes + "&nbsp;&larr;" + "<br>" + "\n" + bpp;
                    textHeight = (isRight) ? textHeight : infoText[side].offsetHeight;
                });
        }

        function setFile() {
            urlFile = getSelValue(select.file, 'value');

            /* Flag for special processing when both left & right are both new. */
            first = 1;
            /* Any view change will update hash. */
            viewOptions.file = getSlugName(select.file.options[select.file.selectedIndex].text);

            setSide('right');
            setSide('left');
        }

        function moveSplit(event) {
            if (splitMode && urlFile) {
                var offset = view.right.getBoundingClientRect();
                splitTarget.x = event.clientX - offset.left;
                splitTarget.y = event.clientY - offset.top;
                if (splitTarget.x < 0) splitTarget.x = 0;
                if (splitTarget.y < textHeight) splitTarget.y = textHeight;
                if (splitTarget.x >= offset.width) splitTarget.x = offset.width - 1;
                if (splitTarget.y >= offset.height) splitTarget.y = offset.height - 1;
                setSplit();
            }
            return false;
        }

        /* Shift key to enter 'flip-view'. Repeat to flip between images. Any other key to return to split-view. */
        function switchMode(keyCode) {
            if (keyCode && keyCode == "16") {
                splitMode = 0;
                var currLeft = (view.left.style.opacity > 0) ? 1 : 0; // current focus
                var switchTo = (currLeft) ? 'right' : 'left'

                infoText.center.innerHTML = getSelValue(select[switchTo], 'folder') + ' '
                    + infoText[switchTo].innerHTML.replace(/&nbsp;/g, '').replace(/←|→/g, '');

                view.left.style.borderRight = "none";
                view.left.style.opacity = 1 - currLeft;
                view.left.style.width = (offset.width - 1) + "px";
            } else if (!splitMode) {
                view.left.style.borderRight = "1px dotted white";
                view.left.style.opacity = 1;
                view.left.style.width = split.x + "px";
                infoText.center.innerHTML = "--- vs ---";
                splitMode = 1;
            }

            infoText.left.style.opacity = splitMode;
            infoText.right.style.opacity = splitMode;
        }

        /* Process URL hash for direct links. */
        function getWindowsOptions() {
            if (window.location.hash) {
                var hashArr, ampArr, imgOpts, name, scale, leftOpts, rightOpts;

                hashArr = (location.hash).split('#', 3);

                ampArr = (hashArr.pop() + '&=' + '&=').split('&', 5);

                imgOpts = ampArr[0].split('*', 2);
                leftOpts = ampArr[1].split('=', 2);
                rightOpts = ampArr[2].split('=', 2);

                for (var opt, j = 0; opt = select.file.options[j]; j++) {
                    if (getSlugName(opt.text) == imgOpts[0]) {
                        select.file.selectedIndex = j;
                        var z, s, q;

                        if (imgOpts[1]) {
                            var z = document.querySelector('#scaleSel [ratio="' + imgOpts[1] + '"]');
                            if (z) { z.selected = true };
                        }
                        if (leftOpts) {
                            s = document.querySelector('#leftSel [value="' + leftOpts[0] + '"]');
                            if (s) { s.selected = true };
                            q = document.querySelector('#leftQual [value="' + leftOpts[1] + '"]');
                            if (q) { q.selected = true };
                            //checkWorkers('left');
                        }
                        if (rightOpts) {
                            s = document.querySelector('#rightSel [value="' + rightOpts[0] + '"]');
                            if (s) { s.selected = true };
                            q = document.querySelector('#rightQual [value="' + rightOpts[1] + '"]');
                            if (q) { q.selected = true };
                            //checkWorkers('right');
                        }
                        break;
                    }
                };
            };
        }

        getWindowsOptions();

        document.addEventListener("DOMContentLoaded", function () {
            fetch("comparisonfiles.json")
                .then(response => response.json())
                .then(function (json) {
                    // subset
                    var subsetSel = document.getElementById("subsetSel");

                    var subsetChange = function (event) {
                        if (!event) {
                            value = subsetSel.value;
                        } else {
                            value = event.target.value;
                        }
                        // format
                        var leftSel = document.getElementById("leftSel");
                        var rightSel = document.getElementById("rightSel");
                        while (leftSel.firstChild) {
                            leftSel.removeChild(leftSel.firstChild);
                        }
                        while (rightSel.firstChild) {
                            rightSel.removeChild(rightSel.firstChild);
                        }
                        for (format of json["comparisonfiles"][value]["format"]) {
                            var optLeft = document.createElement("option");
                            var optRight = document.createElement("option");
                            optLeft.setAttribute("folder", format["name"]);
                            optLeft.text = format["name"];
                            optLeft.value = format["extension"];
                            leftSel.add(optLeft, null);
                            optRight.setAttribute("folder", format["name"]);
                            optRight.text = format["name"];
                            optRight.value = format["extension"];
                            rightSel.add(optRight, null);
                        }
                        // files
                        var fileSel = document.getElementById("fileSel");
                        while (fileSel.firstChild) {
                            fileSel.removeChild(fileSel.firstChild);
                        }
                        var filesList = json["comparisonfiles"][value]["files"]
                        filesList.sort(function(a,b) {
                            if ( a.title < b.title )
                                return -1;
                            if ( a.title > b.title )
                                return 1;
                            return 0;
                        })
                        for (file of filesList) {
                            var opt = document.createElement("option");
                            opt.value = file["filename"];
                            opt.text = file["title"];
                            fileSel.add(opt, null);
                        }
                        urlFolder = "comparisonfiles/" + getSelValue(select.subset, 'value') + "/";
                        setFile();
                    }

                    subsetSel.onchange = subsetChange;

                    for (subset in json['comparisonfiles']) {
                        var opt = document.createElement("option");
                        opt.value = subset;
                        opt.text = subset;
                        subsetSel.add(opt, null);
                    }
                    subsetChange();
                    urlFolder = "comparisonfiles/" + getSelValue(select.subset, 'value') + "/";
                    setFile();
                });
        });
        window.addEventListener("keydown", function (event) {
            switchMode(event.keyCode);
        }, false);

        view.right.addEventListener("mousemove", moveSplit, false);
        view.right.addEventListener("click", moveSplit, false);

        infoText.right.style.backgroundColor = "rgba(0,0,0,.3)";
        infoText.left.style.backgroundColor = "rgba(0,0,0,.3)";
</script>
</body>

</html>
